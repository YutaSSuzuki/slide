[
  {
    "objectID": "reading_circle2023_04.html#quarto",
    "href": "reading_circle2023_04.html#quarto",
    "title": "how to write fast code",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished presentation. To learn more about Quarto presentations see https://quarto.org/docs/presentations/."
  },
  {
    "objectID": "reading_circle2023_04.html#bullets",
    "href": "reading_circle2023_04.html#bullets",
    "title": "how to write fast code",
    "section": "Bullets",
    "text": "Bullets\nWhen you click the Render button a document will be generated that includes:\n\nContent authored with markdown\nOutput from executable code"
  },
  {
    "objectID": "reading_circle2023_04.html#code",
    "href": "reading_circle2023_04.html#code",
    "title": "how to write fast code",
    "section": "Code",
    "text": "Code\nWhen you click the Render button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "slide",
    "section": "",
    "text": "test for slide page\nslide"
  },
  {
    "objectID": "reading_circle2023_04.html#はじめに",
    "href": "reading_circle2023_04.html#はじめに",
    "title": "how to write fast code",
    "section": "はじめに",
    "text": "はじめに\n\n今回紹介する方法は処理や環境によって最適解が異なります。\n自分が行いたい処理を考えた上で必要な手法を選んでください"
  },
  {
    "objectID": "reading_circle2023_04.html#処理の高速化をする４つの方法",
    "href": "reading_circle2023_04.html#処理の高速化をする４つの方法",
    "title": "処理の高速化",
    "section": "処理の高速化をする４つの方法",
    "text": "処理の高速化をする４つの方法\n\n動くプログラムを作成した後に処理の高速化を考える際、参考になる ４つの考え方を紹介します。 \n\n組み込み関数の使用 \n外部モジュールの使用 \nアルゴリズムの最適化 \n並列化\n\n実行環境 3 GHz 6コアIntel Core i5、メモリ:32G python3.10.10"
  },
  {
    "objectID": "reading_circle2023_04.html#自分で作らずあるものを使おう",
    "href": "reading_circle2023_04.html#自分で作らずあるものを使おう",
    "title": "how to write fast code",
    "section": "自分で作らずあるものを使おう",
    "text": "自分で作らずあるものを使おう\n\n1から100000000までの数の総和を計算する。 自作コードの使用\nimport time\nstart_time = time.time()\ntotal = 0\nfor i in range(1,100000001):\n    total += i\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nsumの処理時間: \", end_time - start_time)\n#forループの処理時間: 8.668177366256714\n組み込み関数（sum）の使用\nimport time\nstart_time = time.time()\ntotal = sum(list(range(1,100000001)))\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nsumの処理時間: \", end_time - start_time)\n#forループの処理時間:4.457662105560303"
  },
  {
    "objectID": "reading_circle2023_04.html#組み込み関数を使おう",
    "href": "reading_circle2023_04.html#組み込み関数を使おう",
    "title": "処理の高速化",
    "section": "組み込み関数を使おう",
    "text": "組み込み関数を使おう\n\n1から100000000までの数の総和を計算する。 自作コードの使用\nimport time\nstart_time = time.time()\ntotal = 0\nfor i in range(1,100000001):\n    total += i\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nsumの処理時間: \", end_time - start_time)\n#forループの処理時間: 8.668177366256714秒\n組み込み関数（sum()）の使用\nimport time\nstart_time = time.time()\ntotal = sum(list(range(1,100000001)))\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nsumの処理時間: \", end_time - start_time)\n#forループの処理時間:4.457662105560303秒"
  },
  {
    "objectID": "reading_circle2023_04.html#外部モジュールを使おう",
    "href": "reading_circle2023_04.html#外部モジュールを使おう",
    "title": "処理の高速化",
    "section": "外部モジュールを使おう",
    "text": "外部モジュールを使おう\n\npythonの場合数値計算に最適なNumpyがある。\nNumpyを使用\nimport time\nstart_time = time.time()\nimport numpy\ntotal = numpy.sum(numpy.arange(1,100000001))\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nnumpyの処理時間: \", end_time - start_time)\n#forループの処理時間:0.5025210380554199秒\n実用例：RでCNSとSVの重なりをbiocoductorで検出"
  },
  {
    "objectID": "reading_circle2023_04.html#アルゴリズムを見直そう",
    "href": "reading_circle2023_04.html#アルゴリズムを見直そう",
    "title": "処理の高速化",
    "section": "アルゴリズムを見直そう",
    "text": "アルゴリズムを見直そう\n\nアルゴリズムを見直す際以下の視点がある。\n\n同じ処理をまとめる\nデータの読み書きを減らす\n型の変換を減らす\n\n総和の公式(\\(\\frac n2(1+n)\\))を使用\nimport time\nstart_time = time.time()\ntotal = int(100000000*(1+100000000)/2)\nend_time = time.time()\nprint(\"計算結果:\",total,\"\\nアルゴリズムの変更後の処理時間: \", end_time - start_time)\n#forループの処理時間:1.1920928955078125e-06秒"
  },
  {
    "objectID": "reading_circle2023_04.html#言語を見直そう",
    "href": "reading_circle2023_04.html#言語を見直そう",
    "title": "how to write fast code",
    "section": "言語を見直そう",
    "text": "言語を見直そう\n\n処理速度が早いコンパイル言語を使用することで、インタプリンタ言語を高速化させた時の速度を出せる場合がある。\n#include <iostream>\n#include <chrono>\nusing namespace std;\nint main()\n{\n    int n = 100000000;\n    long sum_ = 0;\n    auto start = chrono::steady_clock::now(); // 開始時刻\n    for (int i = 1; i <= n; i++) {\n        sum_ += i;\n    }\n    auto end = chrono::steady_clock::now(); // 終了時刻\n    auto diff = end - start; // 経過時間\n    cout << \"Sum = \" << sum_ << endl;\n    cout << \"Elapsed time = \" << chrono::duration<double, milli>(diff).count() << \" ms\" << endl;\n    return 0;\n}\n/*C++でのfor文処理時間:0.224624*/"
  },
  {
    "objectID": "reading_circle2023_04.html#おまけ言語を見直そう",
    "href": "reading_circle2023_04.html#おまけ言語を見直そう",
    "title": "処理の高速化",
    "section": "おまけ：言語を見直そう",
    "text": "おまけ：言語を見直そう\n\nコンパイル型言語の使用によりインタプリンタ型言語の 高速化と同じ結果が望める。  chatGPTにより生成したものを修正\n#include <iostream>\n#include <chrono>\nusing namespace std;\nint main()\n{   int n = 100000000;\n    long sum_ = 0;\n    auto start = chrono::steady_clock::now(); // 開始時刻\n    for (int i = 1; i <= n; i++) {\n        sum_ += i;}\n    auto end = chrono::steady_clock::now(); // 終了時刻\n    auto diff = end - start; // 経過時間\n    cout << \"Sum = \" << sum_ << endl;\n    cout << \"Elapsed time = \" << chrono::duration<double, milli>(diff).count() << \" ms\" << endl;\n    return 0;}\n/*C++でのfor文処理時間:0.224624秒*/"
  },
  {
    "objectID": "reading_circle2023_04.html#注意点",
    "href": "reading_circle2023_04.html#注意点",
    "title": "処理の高速化",
    "section": "注意点",
    "text": "注意点\n\n高速化後は結果が変わっていないかを確認しよう 計算過程に少数が入ると整数への変換時に結果が変わることがある。\n\nprint(3/2 + 2/3) # 2.16666\nprint(int(2/3) + int(3/2)) #1\n\n\n適切な方法を使おう 処理によっては紹介した方法では遅くなる場合もある。 １行づつ実行し遅い箇所を特定し最適な方法を探そう。"
  },
  {
    "objectID": "reading_circle2023_04.html#おまけ1並列化をしよう",
    "href": "reading_circle2023_04.html#おまけ1並列化をしよう",
    "title": "コードの高速化",
    "section": "おまけ1：並列化をしよう",
    "text": "おまけ1：並列化をしよう\n\n処理を分割して並列化することで高速化することがある。 chatGPTにより生成したものを修正\nimport time\nstart_time = time.time()\nfrom multiprocessing import Process, Value, Lock\ndef cal(start, end, sum_cal, lock):\n    local_sum = 0\n    for i in range(start, end+1):\n        local_sum += i\n    with lock:\n        sum_cal.value +=local_sum\nif __name__ == '__main__':\n    n =  100000000\n    sum_cal = Value('l', 0)\n    lock = Lock()\n    half = int(n/2)\n    p1 = Process(target=cal, args=(1, half, sum_cal, lock))\n    p2 = Process(target=cal, args=(half+1, n, sum_cal, lock))\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()\n    total = sum_cal.value\n    end_time = time.time()\n    print(\"計算結果:\",total,\"\\n並列化後の処理時間: \", end_time - start_time)\n#並列化後の処理時間:2.640056848526001秒"
  },
  {
    "objectID": "reading_circle2023_04.html#おまけ2言語を見直そう",
    "href": "reading_circle2023_04.html#おまけ2言語を見直そう",
    "title": "コードの高速化",
    "section": "おまけ2：言語を見直そう",
    "text": "おまけ2：言語を見直そう\n\nコンパイル型言語の使用によりインタプリンタ型言語の 高速化と同じ結果が望める。\n#include <iostream>\n#include <chrono>\nusing namespace std;\nint main()\n{   int n = 100000000;\n    long sum_ = 0;\n    auto start = chrono::steady_clock::now(); // 開始時刻\n    for (int i = 1; i <= n; i++) {\n        sum_ += i;}\n    auto end = chrono::steady_clock::now(); // 終了時刻\n    auto diff = end - start; // 経過時間\n    cout << \"Sum = \" << sum_ << endl;\n    cout << \"Elapsed time = \" << chrono::duration<double, milli>(diff).count() << \" ms\" << endl;\n    return 0;}\n/*C++でのfor文処理時間:0.224624*/\nchatGPTにより生成したものを修正"
  },
  {
    "objectID": "reading_circle2023_04.html#並列化をしよう",
    "href": "reading_circle2023_04.html#並列化をしよう",
    "title": "処理の高速化",
    "section": "並列化をしよう",
    "text": "並列化をしよう\n\n処理を分割して並列化することで高速化することがある。 chatGPTにより生成したものを修正\nimport time\nstart_time = time.time()\nfrom multiprocessing import Process, Value, Lock\ndef cal(start, end, sum_cal, lock):\n    local_sum = 0\n    for i in range(start, end+1):\n        local_sum += i\n    with lock:\n        sum_cal.value +=local_sum\nif __name__ == '__main__':\n    n =  100000000\n    sum_cal = Value('l', 0)\n    lock = Lock()\n    half = int(n/2)\n    p1 = Process(target=cal, args=(1, half, sum_cal, lock))\n    p2 = Process(target=cal, args=(half+1, n, sum_cal, lock))\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()\n    total = sum_cal.value\n    end_time = time.time()\n    print(\"計算結果:\",total,\"\\n並列化後の処理時間: \", end_time - start_time)\n#並列化後の処理時間:2.640056848526001秒"
  },
  {
    "objectID": "reading_circle2023_04.html#おまけcの実行方法",
    "href": "reading_circle2023_04.html#おまけcの実行方法",
    "title": "処理の高速化",
    "section": "おまけ:C++の実行方法",
    "text": "おまけ:C++の実行方法\n\nコンパイル\ng ++ <C++のファイル名.cpp> -o <出力したい名前>\n実行\n<出力したファイル名>"
  }
]